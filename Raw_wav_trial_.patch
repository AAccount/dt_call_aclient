Index: aclient/build.gradle
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- aclient/build.gradle	(revision 5b5494a3179396b103a5ea1d8aff50605ed37e45)
+++ aclient/build.gradle	(revision )
@@ -24,5 +24,4 @@
     testCompile 'junit:junit:4.12'
     compile 'com.android.support:appcompat-v7:25.3.1'
     compile 'com.android.support:design:25.3.1'
-    compile 'io.kvh:amr:1.1.1'//amr narrow band library
 }
Index: aclient/src/main/java/dt/call/aclient/background/CmdListener.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- aclient/src/main/java/dt/call/aclient/background/CmdListener.java	(revision 5b5494a3179396b103a5ea1d8aff50605ed37e45)
+++ aclient/src/main/java/dt/call/aclient/background/CmdListener.java	(revision )
@@ -42,14 +42,15 @@
 		while(inputValid)
 		{
 			//responses from the server command connection will always be in text format
-			//timestamp|ring|notavailable|tried_to_call
-			//timestamp|ring|available|tried_to_call
-			//timestamp|ring|incoming|trying_to_call
-			//timestamp|ring|busy|tried_to_call
+			//timestamp|available|tried_to_call
+			//timestamp|incoming|trying_to_call
 			//timestamp|lookup|who|exists
-			//timestamp|call|start|with
-			//timestamp|call|reject|by
-			//timestamp|call|end|by
+			//timestamp|start|with
+			//timestamp|reject|other_person
+			//timestamp|end|other_person
+			//timestamp|prepare|(optionally public key),other_person
+			//timestamp|direct|(encrypted aes key)
+			//timestamp|invalid
 
 			String logd = ""; //accumulate all the diagnostic message together to prevent multiple entries of diagnostics in log ui just for cmd listener
 			try
Index: .idea/misc.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/misc.xml	(revision 5b5494a3179396b103a5ea1d8aff50605ed37e45)
+++ .idea/misc.xml	(revision )
@@ -55,7 +55,7 @@
     <ConfirmationsSetting value="0" id="Add" />
     <ConfirmationsSetting value="0" id="Remove" />
   </component>
-  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_7" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
+  <component name="ProjectRootManager" version="2" languageLevel="JDK_1_8" default="true" assert-keyword="true" jdk-15="true" project-jdk-name="1.8" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/build/classes" />
   </component>
   <component name="ProjectType">
\ No newline at end of file
Index: aclient/src/main/java/dt/call/aclient/screens/CallMain.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- aclient/src/main/java/dt/call/aclient/screens/CallMain.java	(revision 5b5494a3179396b103a5ea1d8aff50605ed37e45)
+++ aclient/src/main/java/dt/call/aclient/screens/CallMain.java	(revision )
@@ -22,6 +22,7 @@
 import android.support.design.widget.FloatingActionButton;
 import android.support.v4.content.ContextCompat;
 import android.support.v7.app.AppCompatActivity;
+import android.util.Log;
 import android.view.View;
 import android.view.Window;
 import android.view.WindowManager;
@@ -31,6 +32,7 @@
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.text.DecimalFormat;
 import java.util.Arrays;
 import java.util.Timer;
 import java.util.TimerTask;
@@ -42,22 +44,27 @@
 import dt.call.aclient.Vars;
 import dt.call.aclient.background.async.CallEndAsync;
 import dt.call.aclient.background.async.CallTimeoutAsync;
-import io.kvh.media.amr.AmrDecoder;
-import io.kvh.media.amr.AmrEncoder;
 
 public class CallMain extends AppCompatActivity implements View.OnClickListener, SensorEventListener
 {
 	private static final String tag = "CallMain";
 
-	private static final int SAMPLESAMR = 8000;
+	//audio track, audio record variables
+	private static final int WAVSAMPLERATE = 8000;
 	private static final int FORMAT = AudioFormat.ENCODING_PCM_16BIT;
 	private static final int STREAMCALL = AudioManager.STREAM_VOICE_CALL;
-	private static final int WAVBUFFERSIZE = 160;
-	private static final int AMRBUFFERSIZE = 32;
-	private static final int ACCUMULATORSIZE = AMRBUFFERSIZE*16;
 	private static final int DIAL_TONE_SIZE = 32000;
-	private static final int HEADERS = 82; //tcp + ip + wikipedia ethernet
 
+	//real time strategy tunable variables
+	private static final int DIVISIONS = 10; //break the audio into X divisions/sec
+	private static final int SEGMENT_TIME_CHECK = 1*(DIVISIONS*60); //MINUTES * divisions/sec
+	private static final int OVERTIME_TOLERATE = 2;
+	private static final int MIN_CORRECTION = 2;
+
+	//real time strategy resulting variables
+	private static final int TIMELIMIT = (1000/ DIVISIONS);
+	private static final int WAVBUFFERSHORTS = (WAVSAMPLERATE/DIVISIONS); //samplerate*16/8 /divisions /2
+
 	//ui stuff
 	private FloatingActionButton end, mic, speaker;
 	private Button noiseReduction, echoCancel, stats;
@@ -71,7 +78,7 @@
 	private int min=0, sec=0;
 	private Timer counter = new Timer();
 	private BroadcastReceiver myReceiver;
-	private int lifetimeSkip=0, tx=0, rx=0;
+	private int lifetimeSkipUnnatural=0, lifetimeSkipCorrection=0, tx=0, rx=0;
 	private String skipLabel, txLabel, rxLabel;
 	private boolean showStats = false;
 
@@ -84,7 +91,7 @@
 	private AudioRecord wavRecorder = null;
 
 	//for dial tone when initiating a call
-	private AudioTrack dialTone = new AudioTrack(STREAMCALL, SAMPLESAMR, AudioFormat.CHANNEL_OUT_MONO, FORMAT, DIAL_TONE_SIZE, AudioTrack.MODE_STATIC);
+	private AudioTrack dialTone = new AudioTrack(STREAMCALL, 8000, AudioFormat.CHANNEL_OUT_MONO, FORMAT, DIAL_TONE_SIZE, AudioTrack.MODE_STATIC);
 
 	@Override
 	protected void onCreate(Bundle savedInstanceState)
@@ -168,32 +175,10 @@
 
 				if(showStats)
 				{
-					String rxDisp, txDisp;
-					if(rx > 1000000)
-					{
-						rxDisp = (rx/1000000) + "M";
-					}
-					else if (rx > 1000)
-					{
-						rxDisp = (rx/1000) + "K";
-					}
-					else
-					{
-						rxDisp = Integer.toString(rx);
-					}
-					if(tx > 1000000)
-					{
-						txDisp = (tx/1000000) + "M";
-					}
-					else if (tx > 1000)
-					{
-						txDisp = (tx/1000) + "K";
-					}
-					else
-					{
-						txDisp = Integer.toString(tx);
-					}
-					final String latestStats = skipLabel + ": " + lifetimeSkip + " " +rxLabel + ": " + rxDisp + " "  + txLabel + ": " + txDisp;
+					String rxDisp = formatInternetMeteric(rx);
+					String txDisp = formatInternetMeteric(tx);
+					final String latestStats = skipLabel + ": " + lifetimeSkipUnnatural + "+(" + lifetimeSkipCorrection + ")" +
+							"\n" +rxLabel + ": " + rxDisp + " "  + txLabel + ": " + txDisp;
 					runOnUiThread(new Runnable()
 					{
 						@Override
@@ -484,13 +469,10 @@
 			{
 				Utils.logcat(Const.LOGD, tag, "MediaCodec encoder thread has started");
 
-				byte[] amrbuffer = new byte[AMRBUFFERSIZE];
-				short[] wavbuffer = new short[WAVBUFFERSIZE];
-				byte[] accumulator = new byte[ACCUMULATORSIZE];
-				int accumulatorPosition = 0;
+				short[] wavshorts = new short[WAVBUFFERSHORTS];
 
 				//setup the wave audio recorder. since it is released and restarted, it needs to be setup here and not onCreate
-				wavRecorder = new AudioRecord(MediaRecorder.AudioSource.DEFAULT, SAMPLESAMR, AudioFormat.CHANNEL_IN_MONO, FORMAT, WAVBUFFERSIZE);
+				wavRecorder = new AudioRecord(MediaRecorder.AudioSource.DEFAULT, WAVSAMPLERATE, AudioFormat.CHANNEL_IN_MONO, FORMAT, WAVBUFFERSHORTS*2);
 				wavRecorder.startRecording();
 
 				//my dying i9300 on CM12.1 sometimes can't get the audio record on its first try
@@ -499,7 +481,7 @@
 				{
 					wavRecorder.stop();
 					wavRecorder.release();
-					wavRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, SAMPLESAMR, AudioFormat.CHANNEL_IN_MONO, FORMAT, WAVBUFFERSIZE);
+					wavRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, WAVSAMPLERATE, AudioFormat.CHANNEL_IN_MONO, FORMAT, WAVBUFFERSHORTS*2);
 					wavRecorder.startRecording();
 					Utils.logcat(Const.LOGW, tag, "audiorecord failed to initialized. retried");
 					recorderRetries--;
@@ -513,8 +495,6 @@
 					endThread();
 				}
 
-				AmrEncoder.init(0);
-
 				while (Vars.state == CallState.INCALL)
 				{
 
@@ -538,11 +518,11 @@
 						micStatusNew = false;
 					}
 
-					int totalRead = 0, dataRead;
-					while (totalRead < WAVBUFFERSIZE)
+					int totalShorts = 0, shortsRead;
+					while (totalShorts < WAVBUFFERSHORTS)
 					{//although unlikely to be necessary, bufferSize the mic input
-						dataRead = wavRecorder.read(wavbuffer, totalRead, WAVBUFFERSIZE - totalRead);
-						totalRead = totalRead + dataRead;
+						shortsRead = wavRecorder.read(wavshorts, totalShorts, WAVBUFFERSHORTS - totalShorts);
+						totalShorts = totalShorts + shortsRead;
 					}
 
 					if(micMute)
@@ -550,27 +530,20 @@
 						//if muting, erase the recorded audio
 						//need to record during mute because a cell phone can generate zeros faster than real time talking
 						//	so you can't just skip the recording and send placeholder zeros in a loop
-						Arrays.fill(wavbuffer, (short)0);
+						Arrays.fill(wavshorts, (short)0);
 					}
 
-					/**
-					 * Send data in 512byte chunks ~ 1/3 of a second. Sending too many 32 byte amr packets
-					 * wastes tons of space in tcp+ip+hardware headers. Also greatly increases the chances of
-					 * packets coming out of order which will increase latency due to reordering fixing. 1/3 of a second
-					 * chosen because that is the minimum offset it takes to notice audio/video out of sync when mixing
-					 * in english audio into hd anime files.
-					 */
-					int encodeLength = AmrEncoder.encode(AmrEncoder.Mode.MR122.ordinal(), wavbuffer, amrbuffer);
-					System.arraycopy(amrbuffer, 0, accumulator, accumulatorPosition, encodeLength);
-					accumulatorPosition = accumulatorPosition + AMRBUFFERSIZE; //guarantee using 32byte chunks
+
 					try
 					{
-						if(accumulatorPosition >= ACCUMULATORSIZE)
-						{
-							accumulatorPosition = 0;
-							Vars.mediaSocket.getOutputStream().write(accumulator, 0, ACCUMULATORSIZE);
-							tx = tx + ACCUMULATORSIZE + HEADERS;
+						byte[] bytes = new byte[WAVBUFFERSHORTS *2];
+						for(int i=0; i<wavshorts.length; i++)
+						{//"encode" from shorts to bytes {1234, 5678} --> {12, 34, 56, 78}
+							bytes[i*2] = (byte)((wavshorts[i] & 0xFF00) >> 8);
+							bytes[i*2+1] = (byte)(wavshorts[i] & 0x00FF);
 						}
+						Vars.mediaSocket.getOutputStream().write(bytes, 0, WAVBUFFERSHORTS *2);
+						tx = tx + WAVBUFFERSHORTS*2;
 					}
 					catch (Exception e)
 					{
@@ -585,7 +558,6 @@
 					}
 				}
 
-				AmrEncoder.exit();
 				wavRecorder.stop();
 				wavRecorder.release();
 				Utils.logcat(Const.LOGD, tag, "MediaCodec encoder thread has stopped");
@@ -623,18 +595,14 @@
 			public void run()
 			{
 				Utils.logcat(Const.LOGD, tag, "MediaCodec decoder thread has started");
-				byte[] amrbuffer = new byte[AMRBUFFERSIZE];
-				short[] wavbuffer = new short[WAVBUFFERSIZE];
-				byte[] accumulator = new byte[ACCUMULATORSIZE];
-				int accumulatorPosition = 0;
+				short[] wavshorts = new short[WAVBUFFERSHORTS];
 
 				//variables for keeping the conversation in close to real time
-				int skipCount = 0, consecutiveOk = 0;
+				int skipCount = 0, errorTime = 0, consecutiveSegments = 0, uncorrectedErrors = 0;
 
 				//setup the wave audio track with enhancements if available
-				AudioTrack wavPlayer = new AudioTrack(STREAMCALL, SAMPLESAMR, AudioFormat.CHANNEL_OUT_MONO, FORMAT, WAVBUFFERSIZE, AudioTrack.MODE_STREAM);
+				AudioTrack wavPlayer = new AudioTrack(STREAMCALL, WAVSAMPLERATE, AudioFormat.CHANNEL_OUT_MONO, FORMAT, WAVBUFFERSHORTS*2, AudioTrack.MODE_STREAM);
 
-				long amrstate = AmrDecoder.init();
 				while(Vars.state == CallState.INCALL)
 				{
 					int totalRead=0, dataRead;
@@ -642,9 +610,10 @@
 					{
 						//read into the accumulator
 						long start = SystemClock.elapsedRealtime();
-						while(totalRead < ACCUMULATORSIZE)
+						byte[] bytes = new byte[WAVBUFFERSHORTS*2];
+						while(totalRead < WAVBUFFERSHORTS*2)
 						{
-							dataRead = Vars.mediaSocket.getInputStream().read(accumulator, totalRead, ACCUMULATORSIZE -totalRead);
+							dataRead = Vars.mediaSocket.getInputStream().read(bytes, totalRead, WAVBUFFERSHORTS*2 -totalRead);
 							totalRead = totalRead + dataRead;
 
 							if(dataRead == -1)
@@ -652,56 +621,88 @@
 								throw new IOException("read from media socket thought it was the end of file (-1)");
 							}
 						}
-						int diff = (int)(SystemClock.elapsedRealtime() - start);
+						int downloadTime = (int)(SystemClock.elapsedRealtime() - start);
 						//https://stackoverflow.com/questions/20852412/does-int-vs-long-comparison-hurt-performance-in-java
 						//http://nicolas.limare.net/pro/notes/2014/12/12_arit_speed/
-						rx = rx + totalRead + HEADERS;
+						rx = rx + totalRead;
 
-						/*
-						 * AMR data is sent every 1/3 of a second in MediaEncoder. If it takes longer than 1/3 of a
-						 * second to receive, the conversation will lag too far compared to what is happening in real time.
-						 */
-						int oldCount = skipCount; //log the old skip counter to know if it was changed
-						int thirdsUsed = (diff / 333) + 1; //how many 1/3 of a second did it take to download? (int division rounds down answer, +1 to compensate)
-						int newSegments = 0;
-						if(thirdsUsed > 1) //if it took more than 1, 1/3 of need to skip segments
+						//"decode" from bytes to shorts {12, 34, 56, 78} --> {1234, 5678}
+						for(int i=0; i<bytes.length; i=i+2)
 						{
-							newSegments = newSegments + thirdsUsed;
+							wavshorts[i/2] = (short)((short)(bytes[i] << 8) + (short)bytes[i+1]);
 						}
-						skipCount = skipCount + newSegments;
-						if(skipCount != oldCount) //if new segments are skipped update counters
+
+						//given the theoretical amount of time it should take to download the segment,
+						//	how many X over the theoretical amount did it take to download the segment
+						int segmentsWaited = (downloadTime / TIMELIMIT) + 1;
+						boolean forceCheck = false;
+
+						//if it is over the tolerated amount of error, fast forward into real time
+						if(segmentsWaited > OVERTIME_TOLERATE)
 						{
-							Utils.logcat(Const.LOGD, tag, "Skip count increased by " + newSegments + " to " + skipCount);
-							lifetimeSkip = lifetimeSkip + newSegments;
-							consecutiveOk = 0;
+							skipCount = skipCount + segmentsWaited;
+							lifetimeSkipUnnatural = lifetimeSkipUnnatural + segmentsWaited;
+							Log.d(tag, "Skip count increased by " + segmentsWaited + " to " + skipCount + " diff: " + downloadTime);
+							forceCheck = true;
 						}
+						else //the download time was either within the time limit or within the tolerated error
+						{
+							//willing to tolerate some lateness and correct it later to avoid an unnecessarily broken up conversation
+							if(segmentsWaited == OVERTIME_TOLERATE)
+							{
+								errorTime = errorTime + downloadTime;
+								uncorrectedErrors++;
+								Log.d(tag, "tolerating: " + downloadTime + " total: " + errorTime);
+							}
+							consecutiveSegments++;
+						}
 
-						int accumulatorMax = ACCUMULATORSIZE;
-						if(consecutiveOk == 4)
-						{//if the conditions are too good, just the act of decoding amr-->wav introduces tiny lag that adds up
-							accumulatorMax = accumulatorMax - AMRBUFFERSIZE;
-							consecutiveOk = 0;
+						if(forceCheck || consecutiveSegments == SEGMENT_TIME_CHECK)
+						{
+							int calculatedTime = uncorrectedErrors*TIMELIMIT; //milliseconds these amount of segments SHOULD have taken
+							int overTime = errorTime - calculatedTime;
+							int correction = (overTime / TIMELIMIT)+1;
+							String logString = "uncorrected: " + uncorrectedErrors + " calculatedTime: " + calculatedTime
+									+ " errorTime: " + errorTime + " overTime: " + overTime + " --> " + correction;
+							Log.d(tag, logString);
+
+							//if the check is because things are going too well, need to skip at least 2 segments
+							if(!forceCheck)
+							{
+								correction = Math.max(correction, MIN_CORRECTION);
+								lifetimeSkipCorrection = lifetimeSkipCorrection + correction;
-						}
+							}
+							else
+							{
+								lifetimeSkipUnnatural = lifetimeSkipUnnatural + correction;
+							}
 
+							//fail safe in case the calculations go horribly wrong
+							if(correction >= 0)
+							{
+								skipCount = skipCount + correction;
+							}
+							else
+							{
+								Utils.logcat(Const.LOGE, tag, "error correction has negatives: " + logString);
+							}
+
+							//whether the correction is from things going well or bad, reset the counters
+							consecutiveSegments = 0;
+							uncorrectedErrors = 0;
+							errorTime = 0;
+						}
+
 						if(skipCount == 0)
 						{//must start and stop the wave player so it only plays when amr is being decoded to prevent buffer underrun delays
 							wavPlayer.play();
-							while (accumulatorPosition < accumulatorMax)
-							{//break up accumulator into amr sized chunks
-								System.arraycopy(accumulator, accumulatorPosition, amrbuffer, 0, AMRBUFFERSIZE);
-								accumulatorPosition = accumulatorPosition + AMRBUFFERSIZE;
-								AmrDecoder.decode(amrstate, amrbuffer, wavbuffer);
-								wavPlayer.write(wavbuffer, 0, WAVBUFFERSIZE);
-							}
+							wavPlayer.write(wavshorts, 0, WAVBUFFERSHORTS);
 							wavPlayer.pause();
-							consecutiveOk++;
 						}
 						else
 						{
 							skipCount--;
-							consecutiveOk = 0;
 						}
-						accumulatorPosition = 0;
 					}
 					catch (Exception i) //io or null pointer depending on when the connection dies
 					{
@@ -727,7 +728,7 @@
 						}
 					}
 				}
-				AmrDecoder.exit(amrstate);
+//				AmrDecoder.exit(amrstate);
 				wavPlayer.stop();
 				wavPlayer.flush(); //must flush after stop
 				wavPlayer.release(); //mandatory cleanup to prevent wavPlayer from outliving its usefulness
@@ -773,5 +774,22 @@
 	public void onAccuracyChanged(Sensor sensor, int accuracy)
 	{
 		//not relevant for proximity sensor so do nothing
+	}
+
+	private String formatInternetMeteric(int n)
+	{
+		DecimalFormat decimalFormat = new DecimalFormat("#.##");
+		if(n > 1000000)
+		{
+			return decimalFormat.format((float)n / (float)1000000) + "M";
+		}
+		else if (n > 1000)
+		{
+			return (n/1000) + "K";
+		}
+		else
+		{
+			return Integer.toString(n);
+		}
 	}
 }
